RouTe — Node.js reverse-proxy фреймворк для маршрутизации запросов

RouTe — это лёгкий Node.js-фреймворк, который работает как единая точка входа для HTTP/HTTPS-трафика и выполняет роль обратного прокси: принимает входящие запросы и маршрутизирует их на локальные сервисы по портам, а также транслирует (проксирует) внешние ресурсы с других доменов через единый контролируемый слой.

## Быстрый старт

1. Установите зависимости:
   ```bash
   npm install
   ```
2. Запустите RouTe:
   ```bash
   npm start
   ```
3. Откройте админ-панель: `http://localhost:3000/RouTe/panel`.
   - Логин и пароль по умолчанию: `admin` / `admin` (настраивается в `config.json`).

Маршруты добавляются через админ-панель и сохраняются в `routes.json`. При каждом запросе RouTe читает этот JSON и выполняет маршрутизацию по декларации.

Что делает RouTe

Port-based routing (localhost): распределяет входящий трафик по правилам на сервисы вида 127.0.0.1:3000, 127.0.0.1:5173, 127.0.0.1:8080 и т.д.

Domain-to-domain proxy: проксирует внешние URL/домены, позволяя “подмешивать” удалённые API/страницы в вашу инфраструктуру как будто они локальные.

Единая политика доступа: централизует контроль заголовков, CORS, куки, rate limit, авторизацию и аудит — на уровне прокси, а не в каждом сервисе.

Гибкая трансляция: переписывание путей (path rewrite), хостов (host rewrite), заголовков (headers), cookie rewrite, и управление редиректами.

Надёжность в проде: health-check, retries, circuit breaker (опционально), таймауты, лимиты тела запроса, защита от “залипания” соединений.

Для кого и зачем

RouTe создан для команд и проектов, где:

несколько сервисов (backend, frontend, админка, websocket, dev-сервер) живут на разных портах;

нужен единый входной домен и прозрачная маршрутизация без “зоопарка” конфигов;

требуется проксирование внешних доменов (интеграции, виджеты, внешние API) через корпоративный контур.

Ключевые сценарии

Монорепо / микросервисы: один домен → много локальных портов.

Dev/Stage/Prod parity: одинаковые правила маршрутизации на всех средах.

Интеграции “через прокси”: внешние домены проходят через ваши политики безопасности и логирования.

Антикризисная миграция: плавно переносите функционал между сервисами, не меняя клиентские URL.

Архитектурно (как продукт)

Core Router Engine — движок правил маршрутизации (port, host, path, headers).

Proxy Transport Layer — проксирование HTTP/HTTPS, WebSocket (при необходимости), streaming.

Policy Middleware — авторизация, CORS, rate limit, observability.

Config-as-Code — декларативные правила в JSON/YAML/JS с горячей перезагрузкой (по задумке продукта).

Принцип, который продаёт

RouTe превращает набор сервисов и внешних источников в управляемую “платформу” с единым входом, едиными правилами и предсказуемой эксплуатацией.
И да: это тот редкий случай, когда “прокси” — это не костыль, а слой управления.
